"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startListeners = startListeners;
const const_1 = require("../../common/const");
const inputErrorHandler_1 = require("../../common/errors/inputErrorHandler");
const Websocket_1 = require("../../homeAssistant/Websocket");
const helpers_1 = require("../trigger-state/helpers");
function startListeners(clientEvents, controller, homeAssistant, node, status) {
    if (node.config.entities[const_1.IdSelectorType.Substring].length === 0 &&
        node.config.entities[const_1.IdSelectorType.Regex].length === 0) {
        for (const entity of node.config.entities[const_1.IdSelectorType.Entity]) {
            const eventTopic = `ha_events:state_changed:${entity}`;
            clientEvents.addListener(eventTopic, controller.onHaEventsStateChanged.bind(controller));
        }
    }
    else {
        clientEvents.addListener('ha_events:state_changed', controller.onHaEventsStateChanged.bind(controller));
    }
    if (node.config.outputInitially) {
        const generateStateChanges = async () => {
            const events = (0, helpers_1.createStateChangeEvents)(homeAssistant);
            for (const event of events) {
                await controller
                    .onHaEventsStateChanged(event, true)
                    .catch((e) => {
                    const { error, statusMessage } = (0, inputErrorHandler_1.getErrorData)(e);
                    status.setError(statusMessage);
                    node.error(error);
                });
            }
        };
        // Here for when the node is deploy without the server config being deployed
        if (homeAssistant.isHomeAssistantRunning) {
            generateStateChanges();
        }
        else {
            clientEvents.addListener(Websocket_1.ClientEvent.InitialConnectionReady, generateStateChanges);
        }
    }
}
