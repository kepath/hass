"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publishIssueUpdate = void 0;
exports.getHomeAssistant = getHomeAssistant;
exports.getServerId = getServerId;
exports.includesIssue = includesIssue;
exports.isIssuesEqual = isIssuesEqual;
exports.isDynamicValue = isDynamicValue;
exports.isHomeAssistantDataLoaded = isHomeAssistantDataLoaded;
exports.isHomeAssistantNode = isHomeAssistantNode;
exports.isNodeDisabled = isNodeDisabled;
const lodash_1 = require("lodash");
const const_1 = require("../../../const");
const globals_1 = require("../../../globals");
const assert_1 = require("../../../helpers/assert");
const utils_1 = require("../../../helpers/utils");
const homeAssistant_1 = require("../../../homeAssistant");
/**
 * Get the Home Assistant instance from the node.
 *
 * @param node  The node to get the Home Assistant instance from
 * @returns  The Home Assistant instance
 */
function getHomeAssistant(node) {
    if (node.type === const_1.NodeType.Server) {
        return homeAssistant_1.homeAssistantConnections.get(node.id);
    }
    if ('server' in node && (0, assert_1.isString)(node.server)) {
        const server = globals_1.RED.nodes.getNode(node.server);
        if (!server) {
            return;
        }
        return homeAssistant_1.homeAssistantConnections.get(server.id);
    }
}
/**
 * Get the server ID from the node.
 *
 * @param node  The node to get the server ID from
 * @returns  The server ID
 */
function getServerId(node) {
    if (node.type === const_1.NodeType.Server) {
        return node.id;
    }
    return node.server;
}
/**
 * Check if the issue is included in the array of issues.
 *
 * @param issues  The array of issues to check
 * @param issue  The issue to check for
 * @returns {boolean}  True if the issue is included in the array of issues
 */
function includesIssue(issues, issue) {
    return issues.some((i) => isSameIssue(i, issue));
}
function isIssuesEqual(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    return a.every((issue, index) => isSameIssue(issue, b[index]));
}
/**
 * Check if the value is a mustache template or a Node-RED environment variable.
 *
 * @param value
 * @returns {boolean}
 */
function isDynamicValue(value) {
    return (0, utils_1.containsMustache)(value) || (0, utils_1.isNodeRedEnvVar)(value);
}
/**
 * Check if all the registries, states and services data are loaded.
 *
 * @param node  The node to check
 * @returns {boolean | undefined} True if the Home Assistant data is loaded
 */
function isHomeAssistantDataLoaded(node) {
    const ha = getHomeAssistant(node);
    return ha === null || ha === void 0 ? void 0 : ha.websocket.isAllRegistriesLoaded;
}
/**
 * Check if the node is a Home Assistant node.
 *
 * @param node  The node to check
 * @returns {boolean} True if the node is a Home Assistant node
 */
function isHomeAssistantNode(node) {
    return Object.values(const_1.NodeType).includes(node.type);
}
/**
 * Check if the issues are the same.
 *
 * @param a  The first issue to compare
 * @param b  The second issue to compare
 * @returns  True if the issues are the same
 */
function isSameIssue(a, b) {
    return (a.type === b.type &&
        a.identity === b.identity &&
        a.message === b.message);
}
exports.publishIssueUpdate = (0, lodash_1.throttle)((issues) => {
    globals_1.RED.log.debug('[Home Assistant] Issues sent to client');
    globals_1.RED.comms.publish(`homeassistant/issues`, issues, true);
}, 500);
function isNodeDisabled(node, tab) {
    // @ts-expect-error - d is not defined in NodeDef
    if (node.d === true) {
        return true;
    }
    return !!tab;
}
