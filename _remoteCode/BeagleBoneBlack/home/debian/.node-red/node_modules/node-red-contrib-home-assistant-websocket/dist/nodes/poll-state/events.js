"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startListeners = startListeners;
const inputErrorHandler_1 = require("../../common/errors/inputErrorHandler");
const const_1 = require("../../const");
const utils_1 = require("../../helpers/utils");
const homeAssistant_1 = require("../../homeAssistant");
const Websocket_1 = require("../../homeAssistant/Websocket");
async function startListeners({ config, clientEvents, controller, homeAssistant, node, status, }) {
    if (config.outputOnChanged) {
        clientEvents.addListener(`${const_1.HA_EVENTS}:${homeAssistant_1.HaEvent.StateChanged}:${config.entityId}`, controller.onTimer.bind(controller));
    }
    if (config.outputInitially) {
        if (homeAssistant.isHomeAssistantRunning) {
            await controller.onTimer().catch((e) => {
                const { error, statusMessage } = (0, inputErrorHandler_1.getErrorData)(e);
                status.setError(statusMessage);
                node.error(error);
            });
        }
        else {
            clientEvents.addListener(Websocket_1.ClientEvent.InitialConnectionReady, controller.onTimer.bind(controller));
        }
    }
    if (homeAssistant.isHomeAssistantRunning) {
        await controller.onIntervalUpdate().catch((e) => {
            const { error, statusMessage } = (0, inputErrorHandler_1.getErrorData)(e);
            status.setError(statusMessage);
            node.error(error);
        });
    }
    else {
        clientEvents.addListener(Websocket_1.ClientEvent.Ready, controller.onIntervalUpdate.bind(controller));
    }
    if (config.updateIntervalType === const_1.TypedInputTypes.JSONata &&
        config.updateInterval.length > 12) {
        const ids = (0, utils_1.getEntitiesFromJsonata)(config.updateInterval);
        ids.forEach((id) => {
            clientEvents.addListener(`${const_1.HA_EVENTS}:${homeAssistant_1.HaEvent.StateChanged}:${id}`, controller.onIntervalUpdate.bind(controller));
        });
    }
}
