"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const InputOutputController_1 = __importDefault(require("../../common/controllers/InputOutputController"));
const InputError_1 = __importDefault(require("../../common/errors/InputError"));
const NoConnectionError_1 = __importDefault(require("../../common/errors/NoConnectionError"));
const InputService_1 = require("../../common/services/InputService");
const const_1 = require("../../const");
const mustache_1 = require("../../helpers/mustache");
const _1 = require(".");
class ApiController extends InputOutputController_1.default {
    async onInput({ message, parsedMessage, send, done, }) {
        var _a;
        if (!this.homeAssistant.websocket.isConnected) {
            throw new NoConnectionError_1.default();
        }
        const renderTemplate = (0, mustache_1.generateRenderTemplate)(message, this.node.context(), this.homeAssistant.websocket.getStates());
        let data;
        if (parsedMessage.data.source === InputService_1.DataSource.Message) {
            data = parsedMessage.data.value;
        }
        else if (((_a = parsedMessage.data.value) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            if (parsedMessage.dataType.value === const_1.TypedInputTypes.JSONata) {
                data = await this.jsonataService.evaluate(parsedMessage.data.value, {
                    message,
                });
            }
            else {
                data = JSON.parse(renderTemplate(typeof parsedMessage.data.value === 'object'
                    ? JSON.stringify(parsedMessage.data.value)
                    : parsedMessage.data.value));
            }
        }
        let results;
        if (parsedMessage.protocol.value === _1.ApiProtocol.Http) {
            const path = renderTemplate(parsedMessage.path.value).replace(/^\/(?:api\/)?/, '');
            if (!path) {
                throw new InputError_1.default('ha-api.error.requires_path');
            }
            if (!Object.values(_1.ApiMethod).includes(parsedMessage.method.value)) {
                throw new InputError_1.default([
                    'ha-api.error.invalid_method',
                    { method: parsedMessage.method.value },
                ]);
            }
            const method = parsedMessage.method.value;
            this.debugToClient({ method, path, data });
            if (method === _1.ApiMethod.Get) {
                results = await this.homeAssistant.http.get(path, data, parsedMessage.responseType.value);
            }
            else {
                results = await this.homeAssistant.http.post(path, data, parsedMessage.responseType.value);
            }
        }
        else {
            if (!('type' in data)) {
                throw new InputError_1.default('ha-api.error.requires_type');
            }
            this.debugToClient(JSON.stringify(data));
            this.status.setSending();
            results = this.homeAssistant.websocket.send(data);
        }
        await this.setCustomOutputs(parsedMessage.outputProperties.value, message, {
            results,
            config: this.node.config,
        });
        this.status.setSuccess([
            'ha-api.status.method_called',
            { method: parsedMessage.protocol.value },
        ]);
        send(message);
        done();
    }
}
exports.default = ApiController;
