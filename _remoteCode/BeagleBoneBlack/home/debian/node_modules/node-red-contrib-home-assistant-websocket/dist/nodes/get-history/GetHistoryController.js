"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const timestring_1 = __importDefault(require("timestring"));
const InputOutputController_1 = __importDefault(require("../../common/controllers/InputOutputController"));
const SendSplitMixin_1 = __importDefault(require("../../common/controllers/SendSplitMixin"));
const InputError_1 = __importDefault(require("../../common/errors/InputError"));
const NoConnectionError_1 = __importDefault(require("../../common/errors/NoConnectionError"));
const InputService_1 = require("../../common/services/InputService");
const mustache_1 = require("../../helpers/mustache");
const const_1 = require("./const");
const SendSplitController = (0, SendSplitMixin_1.default)((InputOutputController_1.default));
class GetHistoryController extends SendSplitController {
    async onInput({ message, parsedMessage, send, done, }) {
        if (!this.homeAssistant.websocket.isConnected) {
            throw new NoConnectionError_1.default();
        }
        const { entityIdType, relativeTime } = parsedMessage;
        const flatten = parsedMessage.flatten.value;
        let startDate = new Date(parsedMessage.startDate.value);
        let endDate = new Date(parsedMessage.endDate.value);
        let entityId;
        if (parsedMessage.entityId.source === InputService_1.DataSource.Message) {
            entityId = parsedMessage.entityId.value;
        }
        else {
            // Only render the template if it's from the config
            entityId = (0, mustache_1.renderTemplate)(parsedMessage.entityId.value, message, this.node.context(), this.homeAssistant.websocket.getStates());
        }
        if (parsedMessage.entityIdType.value === const_1.EntityFilterType.Regex) {
            const entities = Object.keys(this.homeAssistant.websocket.getStates());
            const regex = new RegExp(entityId);
            entityId = entities
                .filter((entity) => regex.test(entity))
                .join(',');
            if (!entityId) {
                throw new InputError_1.default('api-get-history.error.no_entity_ids_matched');
            }
        }
        if (this.node.config.useRelativeTime ||
            // If the relative time is from the message, we need to check if it's a relative time
            parsedMessage.relativeTime.source === InputService_1.DataSource.Message) {
            try {
                const relativeTimeMs = (0, timestring_1.default)(relativeTime.value, 'ms');
                startDate = new Date(Date.now() - relativeTimeMs);
                endDate = new Date();
            }
            catch (e) {
                throw new InputError_1.default('api-get-history.error.invalid_relative_time');
            }
        }
        this.status.setSending('api-get-history.status.requesting');
        let results = await this.homeAssistant.http.getHistory(isNaN(startDate.getTime()) ? '' : startDate.toISOString(), entityId, isNaN(endDate.getTime()) ? '' : endDate.toISOString(), flatten);
        switch (this.node.config.outputType) {
            case const_1.OutputType.Split:
                if (results.length === 0) {
                    this.status.setFailed('api-get-history.status.no_results');
                    done();
                    return;
                }
                if (entityIdType.value === const_1.EntityFilterType.Equals &&
                    !flatten &&
                    Array.isArray(results[0])) {
                    results = results[0];
                }
                this.sendSplit(message, results, send);
                break;
            case const_1.OutputType.Array:
            default:
                this.contextService.set(results, this.node.config.outputLocationType, this.node.config.outputLocation, message);
                send(message);
                break;
        }
        this.status.setSuccess();
        done();
    }
}
exports.default = GetHistoryController;
